# プロジェクト規模でアーキテクチャを変える判断基準

## はじめに

前回の記事では、「プロジェクトの規模によって適切なアーキテクチャが変わる」という大枠を説明しました。

今回は、**具体的にどう判断するか**の基準を詳しく解説します。

---

## 前提: アーキテクチャは道具である

まず重要な前提を確認します。

```
アーキテクチャ = 道具
道具 ≠ 絶対法則
```

道具は**使うべき場面**があり、**使うべきでない場面**もあります。ドライバーでネジを締めるのは正しいですが、釘を打つには向いていません。

アーキテクチャも同じです。

---

## Promps: 意図的にミニマルな設計

### なぜミニマルなのか

Prompsは**意図的に**小さく設計されています。

```
目的: DSL → 自然言語変換（1つだけ）
フェーズ数: 5-10個（有限）
依存関係: 一方向のみ
相互依存: 最小限
複雑さ: 意図的に低い
```

### ミニマルの理由（重要）

これは以下の理由ではありません：

❌ 時間がない
❌ プロトタイプだから
❌ 野心が小さい

本当の理由：

✅ **純粋なレイヤードアーキテクチャを可能にするため**
✅ **アーキテクチャ実験のため**
✅ **ドキュメント化を簡単にするため**
✅ **設計原則を証明するため**
✅ **参照実装として機能させるため**

### Unix哲学の適用

```
"Do one thing and do it well"
（1つのことをうまくやる）
  ↓
PrompはDSL変換という1つのことだけをやる
  ↓
だから純粋なレイヤードアーキテクチャが可能
```

---

## KakeiBon: 必然的に複雑

### システムの特性

```
目的: 複数（ユーザー管理、取引記録、暗号化、レポート、i18n...）
機能: 10+画面
テーブル: 10+個
テスト: 525件
依存関係: 双方向（取引 ↔ 口座 ↔ カテゴリ）
複雑さ: 本質的に高い
```

### レイヤードアーキテクチャを厳密に適用したら？

もし厳密にレイヤードアーキテクチャを適用していたら：

```
Phase 0: データベースアクセス
Phase 1: 暗号化レイヤー
Phase 2: ユーザー管理
Phase 3: 口座管理
Phase 4: カテゴリ管理
Phase 5: 取引管理
Phase 6: 集計機能
Phase 7: UIレイヤー
...
Phase 15-20: ???

問題:
- フェーズが多すぎる（管理不可能）
- 複雑な相互依存（循環依存が避けられない）
- フィーチャーブランチ爆発（15-20個の永続ブランチ）
- API安定性が不可能（すべてが他のすべてに依存）
```

### KakeiBonが実際に使ったもの

- モジュール化（レイヤー化ではない）
- 戦略的な共通化
- SQL一元管理
- 定数の外部化
- 伝統的なGit Flow（フィーチャーブランチはマージ後削除）

---

## 規模とアーキテクチャの対応表

| 規模 | フェーズ数 | アーキテクチャ | ブランチ戦略 | 例 |
|------|----------|--------------|-------------|-----|
| **小** | 5-10 | 純粋レイヤード | Persistent Feature Branch | Promps |
| **中** | 10-20 | ハイブリッド（レイヤード+モジュラー） | 修正版Git Flow | - |
| **大** | 20+ | マイクロサービス/モジュラー | Feature Flags / Trunk-based | KakeiBon |

---

## レイヤードアーキテクチャが機能する条件

### 理想的な条件

✅ **単一の主要目的**
- 例: Promps（DSL変換のみ）

✅ **有限なレイヤー数** (< 10)
- すべてのフェーズを事前に列挙可能

✅ **明確なレイヤー境界**
- 各フェーズに明確な責務がある

✅ **一方向の依存関係**
- 上位レイヤーは下位レイヤーにのみ依存

✅ **最小限の相互依存**
- レイヤー間で横方向の通信が不要

✅ **安定したコアレイヤー**
- Phase 0 APIが不変を保てる

### 条件が満たされると得られるもの

条件が満たされると、以下が**自動的に**得られます：

- 粗結合（自動的に発生）
- 簡単なモジュール分離
- 永続フィーチャーブランチが機能
- API安定性ポリシーが実用的
- マージコンフリクトが稀

---

## レイヤードアーキテクチャが失敗する兆候

### 警告サイン

❌ **複数の競合する目的**
- 例: "ユーザー管理 AND レポート AND 暗号化 AND..."

❌ **不明確なレイヤー数**
- 「進めながらレイヤーを決めよう」

❌ **曖昧な境界**
- 「この機能はPhase 3かPhase 5か...」

❌ **循環依存**
- 取引がカテゴリを必要とし、カテゴリが取引を必要とする

❌ **多くの相互依存**
- すべての機能が5+の他機能に触れる

❌ **不安定なコア**
- Phase 0 APIが頻繁に変更が必要

### 失敗すると何が起こるか

- 密結合が発生
- モジュール分離が困難
- 永続ブランチが負担に
- API安定性が不可能
- マージコンフリクトが頻発

### 代替アプローチ

**中規模プロジェクト用**:
- モジュラーアーキテクチャ（レイヤードではない）
- サービス指向アーキテクチャ
- プラグインアーキテクチャ

**大規模プロジェクト用**:
- マイクロサービス
- Feature Flags
- Trunk-based開発

---

## 判断のための5つの質問

新しいプロジェクトを始める前に、この5つの質問に答えてください。

### Q1: 明確な目的はいくつありますか？

- **1つ** → レイヤードアーキテクチャを検討
- **複数** → モジュラーアーキテクチャを検討

### Q2: すべてのフェーズを事前に列挙できますか？

- **はい、< 10個** → レイヤードが機能するかも
- **いいえ、または > 10個** → モジュラーが安全

### Q3: 依存関係は一方向ですか？

- **ほぼ一方向** → レイヤードが機能するかも
- **いいえ（循環依存）** → モジュラーが安全

### Q4: コアは安定していますか？

- **はい** → API安定性ポリシーが機能
- **いいえ** → バージョニング/非推奨化を使用

### Q5: 開発者は何人ですか？

- **1-3人** → 永続ブランチが機能
- **10人以上** → 伝統的なGit Flow

---

## 実践例: Prompsでの判断プロセス

### 5つの質問への回答

**Q1: 目的の数**
```
回答: 1つ（DSL → 自然言語変換）
結論: レイヤードアーキテクチャを検討 ✓
```

**Q2: フェーズの列挙**
```
回答: はい
  - Phase 0: コアパース
  - Phase 1: GUI
  - Phase 2: パーティクルブロック
  - Phase 3: 動詞ブロック
  - Phase N: ロジックチェック
  - Phase N+1: ファイルI/O
  - Phase N+2: レイアウト
合計: 7フェーズ（< 10）
結論: レイヤードが機能するかも ✓
```

**Q3: 依存関係**
```
回答: 一方向のみ
  Phase N → Phase 0（呼び出しのみ）
  Phase 0 ← Phase N（変更なし）
結論: レイヤードが機能するかも ✓
```

**Q4: コアの安定性**
```
回答: はい
  Phase 0 APIは不変
  新機能 = 新関数（既存を変更しない）
結論: API安定性ポリシーが機能 ✓
```

**Q5: 開発者数**
```
回答: 1-3人
結論: 永続ブランチが機能 ✓
```

### 最終判断

```
5/5の条件を満たす
  ↓
レイヤードアーキテクチャを採用 ✅
  ↓
結果: うまくいった
  - 68テスト、100%成功率
  - マージコンフリクトなし
  - モジュール分離が簡単
```

---

## KakeiBonとPrompの知識伝達

### KakeiBonが教えてくれたこと（実践）

```
暗黙のパターンを発見:
- モジュール化が機能
- 共通化が重要
- SQL一元管理が認知負荷を減らす
- 定数外部化が明確性を向上
- 即時テストが早期に問題を捕捉
```

### Promsが形式化したこと（理論）

```
明示的な原則を抽出:
- レイヤードアーキテクチャ（規模が許す場合）
- 非破壊拡張原則
- API安定性ポリシー
- 永続フィーチャーブランチ戦略
- 創発特性としての粗結合
```

### 相補的関係

```
KakeiBon（複雑システム）
  ↓ 実践からパターンを抽出
Promps（シンプルシステム）
  ↓ 設計原則として形式化
.ai-context/（ドキュメント）
  ↓ 再利用可能な知識
未来のプロジェクト
```

**一緒に、別々ではない**:
- KakeBon単独 → "うまくいったけど、なぜ？"
- Promps単独 → "いい理論だけど、機能する？"
- **両方** → 実践 ↔ 理論の統合

---

## このアプローチの拡張性の限界

### Prompsアプローチが機能するとき

```
フェーズ数: 5-10（管理可能）
フィーチャーブランチ: 5-10（追跡可能）
開発者: 1-3人（調整が簡単）
目的: 単一（明確な境界）
```

### 破綻するとき

```
フェーズ数: 15-20+（圧倒的）
フィーチャーブランチ: 15-20+（混沌）
開発者: 10+（調整が困難）
目的: 複数（曖昧な境界）
```

---

## 新規プロジェクトのための意思決定フレームワーク

### ステップ1: 規模を評価

```bash
# フェーズ数を推定
# もし < 10: レイヤードを検討
# もし > 10: モジュラーを検討
```

### ステップ2: 依存関係をチェック

```bash
# 依存関係グラフを描く
# もしほぼ一方向: レイヤードが機能
# もし多くの循環: モジュラーが安全
```

### ステップ3: チームを評価

```bash
# もし小チーム（1-3人）: 永続ブランチOK
# もし大チーム（10+人）: 伝統的なGit Flow
```

### ステップ4: 最小限から始める

```bash
# コアのみを実装
# アーキテクチャが機能するか検証
# その後拡張
```

---

## よくある誤解

### 誤解1: 「レイヤーが多い = より良いアーキテクチャ」

```
❌ 間違い: より多くのレイヤー = より良い分離

✅ 正しい: 適切な数のレイヤー = 管理可能な複雑さ
```

### 誤解2: 「すべてのプロジェクトにレイヤードを使うべき」

```
❌ 間違い: レイヤードアーキテクチャは普遍的

✅ 正しい: レイヤードは小規模に最適、大規模には不向き
```

### 誤解3: 「小さいプロジェクト = 手抜き設計」

```
❌ 間違い: Prompsは小さいから簡単

✅ 正しい: Prompsは意図的にミニマル（アーキテクチャ実験のため）
```

---

## 実践的なアドバイス

### 新規プロジェクトを始めるとき

**1. まず規模を見積もる**
```
Q: このプロジェクトには何個のレイヤーが必要か？
A: < 10 → レイヤードを試してみる
A: > 10 → 別のアプローチを検討
```

**2. 小さく始める**
```
最初の3-5フェーズを実装
  ↓
アーキテクチャが機能するか検証
  ↓
機能すれば続行、しなければ調整
```

**3. 早期に問題を検出**
```
即時テスト
  ↓
早期に設計問題を発見
  ↓
大きくなる前に修正
```

### 既存プロジェクトを評価するとき

**兆候: レイヤードが機能していない**
```
- 頻繁なマージコンフリクト
- API変更が至る所で破壊を引き起こす
- ブランチ管理が負担
- モジュール分離が困難
```

**対策:**
```
1. 5つの質問に答える
2. 条件が満たされているか評価
3. 満たされていない → 別のアーキテクチャを検討
4. リファクタリング計画を立てる
```

---

## まとめ

### 重要ポイント

**1. アーキテクチャは道具である**
- 万能なアーキテクチャは存在しない
- 規模に応じて選択する

**2. 小規模（5-10フェーズ）: レイヤードが機能**
- 純粋なレイヤードアーキテクチャ
- 永続フィーチャーブランチ
- API安定性ポリシー

**3. 大規模（15-20+フェーズ）: モジュラーが必要**
- モジュラーアーキテクチャ
- 伝統的なGit Flow
- バージョニング/非推奨化

**4. 開始前に5つの質問で判断**
- 目的の数
- フェーズの列挙可能性
- 依存関係の方向性
- コアの安定性
- チームサイズ

**5. PrompとKakeiBonは相補的**
- 実践からの学び ↔ 理論的形式化
- 両方から学ぶことが重要

---

## 次回予告

次回は、レイヤードアーキテクチャで**なぜ粗結合が自動的に生まれるのか**、その仕組みを詳しく解説します。

具体的には：
- 非破壊拡張原則とは何か
- なぜ粗結合が「創発特性」なのか
- Prompsでの実例
- 伝統的アプローチとの比較

お楽しみに！

---

## 参考資料

この記事の内容は、OSSプロジェクト「Promps」の開発ドキュメントから抽出しています。

- **GitHub**: https://github.com/BonoJovi/Promps
- **詳細ドキュメント**:
  - [SCALE_AND_ARCHITECTURE.md](https://github.com/BonoJovi/Promps/blob/dev/.ai-context/core/SCALE_AND_ARCHITECTURE.md)
  - [DESIGN_PHILOSOPHY.md](https://github.com/BonoJovi/Promps/blob/dev/.ai-context/core/DESIGN_PHILOSOPHY.md)
- **ライセンス**: MIT License (2025 Yoshihiro NAKAHARA)

---

## 執筆について

この記事は、著者（Yoshihiro NAKAHARA）の設計思想と実践経験をAI（Claude）とのセッションを通じて言語化し、原稿に書き起こしたものです。

- **思考の整理**: 複数プロジェクト（KakeiBon、Promps）での実践を通じて得た暗黙知を、対話を通じて明文化
- **原稿執筆**: Claudeが構成・執筆を担当
- **内容検証**: 著者が技術的正確性とニュアンスを確認

すべての設計判断と技術的洞察は著者の実務経験に基づいています。
